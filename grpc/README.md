# GRPC
在这里，我们将了解 gRPC 是什么以及如何使用 Go 编程语言实现它。一定要准备好笔记本或文本编辑器来做笔记以备将来参考。另外，如果您有兴趣，请浏览本网站上的其他一些教程。

## Introduction to gRPC with Golang

### Why gRPC?
今天，应用程序是用多种语言编写的——一种用于前端，另一种用于数据库，另一种用于后端，一种用于 Android 应用程序，另一种用于 iOS。所以，很明显，他们都需要相互交流。要做到这一点，他们都需要遵守一组单一的 API 合约：

- 沟通渠道
- 验证 
- 有效载荷格式 
- 数据模型 
- 错误处理

所有这些都必须高效（轻便且快速）且简单。我们使用 gRPC 完成所有这些工作。

### What is gRPC?
它是最初由 Google 开发的高性能开源功能丰富的框架，现在是云原生计算基金会（或 CNCF）的一部分，就像 Kubernetes 或 Prometheus 一样。

RPC 代表远程过程调用，而 g 不代表 Google。相反，它在良好、绿色和光荣、游戏、gon 等之间发生了变化（我知道……我知道……）。

它是一种协议，允许程序执行位于另一台计算机中的另一个程序的过程。最好的一点是，开发人员不必显式编码网络交互的细节，由底层框架自动处理。所以在客户端代码中，看起来我们只是直接调用了服务端代码的一个函数。即使客户端和服务器上的代码是用不同的编程语言编写的，它也可以工作。

它的工作原理是客户端有一个存根，它提供与服务器相同的方法或功能。 gRPC 会自动为您生成存根。存根将在底层调用 gRPC 框架，通过网络与服务器交换信息。

多亏了存根，客户端和服务器现在只需要关心实现其核心服务的逻辑。我们将在后续文章中了解如何借助协议缓冲区生成 gRPC 存根。

### Code generation by gRPC
代码生成是 gRPC 最重要的特性之一。为了为服务器和客户端生成存根，我们首先需要编写 API 合约，其中包括服务的描述及其在协议缓冲区文件中的有效负载消息（它具有 .proto 扩展名）。

```go
syntax = 'proto3';
 
message HelloRequest (
    string name = 1;
)
 
message HelloResponse (
    string greet = 1;
)
 
service Welcome (
rpc Hello(HelloRequest) returns (HelloResponse);
)
```

从这个 proto 文件中，服务器和客户端存根代码由协议缓冲区编译器（或 protoc）生成。生成的 Go 代码将是这样的：

```go
//Go code
...
 
type HelloRequest struct {
     Name string
}
 
type HelloResponse struct {
     Greet string
}
 
type WelcomeServiceClient interface {
     Hello(*HelloRequest) (*HelloResponse, error)
}
 
type WelcomeServiceServer interface {
     Hello(*HelloRequest) (*HelloResponse, error)
}
```

它以二进制格式表示数据，这种格式更小，传输速度更快。序列化也比一些基于文本的格式（如 JSON 或 XML）更有效。它在客户端和服务器之间提供了一个强类型的 API 契约，使用起来非常安全。它有一套很好的 API 演进规则，以确保向后和向前兼容。

在 HTTP/2（grpc 使用的传输协议）中也可以进行多路复用，这意味着客户端和服务器可以通过单个 TCP 连接并行发送多个请求和响应。这将有助于减少延迟并提高网络利用率。

### Types of gRPC

gRPC 有 4 种类型：

- 最简单的是一元的——客户端发送 1 条请求消息，服务器回复 1 条响应

- 客户端流式传输——客户端将发送多条消息流，并且它希望服务器只发回 1 个单一响应

- 服务器流式传输 - 客户端仅发送 1 条请求消息，服务器以多条消息流进行回复

- 双向或双向流——客户端和服务器将继续以任意顺序并行发送和接收多条消息。它非常灵活且没有阻塞，这意味着在发送下一条消息之前，没有任何一方需要等待响应。

这将它与 REST 之类的服务区分开来，后者只允许从客户端到服务器的单向请求。然而，虽然所有浏览器都完全支持 REST，但对 gRPC 的支持是有限的。

gRPC 的主要用途是微服务的实现。 （微服务一般也出现在一些电子游戏中，可以在游戏中为你的游戏角色购买特殊的衣服和配饰。）

由于 gRPC 支持低延迟和高速通信，以及强大的 API 合约，因此非常适合此类快速、安全的交易。

在下一部分中，我们将看到如何实现一元 gRPC 等等。


## Unary gRPC with Golang（一元 gRPC）

由于我们涵盖了所有基础知识，我们将直接开始使用 GO 实现一元 gRPC。

- Define a proto service
- Implement server in Go
- Implement client in Go
- Error Handling

### Homebrew and Protoc Installation（Homebrew 和 Protoc 安装）

按照原网站上的说明安装 Homebrew：

- https://docs.brew.sh/Homebrew-on-Linux
- https://brew.sh/

然后，我们使用命令安装ProtoC：

```shell
go get -u google.golang.org/grpc
go get -u github.com/golang/protobuf/protoc-gen-go
```

### Implementing the gRPC

所以让我们从实现开始。首先，我们创建一个文件夹来存储我们所有的 proto 文件，然后在其中创建一个新文件 mem_message.proto。这将与内存交互：

```go
syntax = "proto3";
```

然后我们创建内存单元，然后我们可以将其分配给其他函数：

```go
message Memory {
  enum Unit {
    UNKNOWN = 0;
    BIT = 1;
    BYTE = 2;
    KILOBYTE = 3;
    MEGABYTE = 4;
    GIGABYTE = 5;
    TERABYTE = 6;
  }
 
  uint64 value = 1;
  Unit unit = 2;
}
```

同样，我们使用内存创建处理器消息：

```go
import "memory_message.proto";
 
message CPU {
  string brand = 1;
  string name = 2;
  uint32 number_cores = 3;
  uint32 number_threads = 4;
  double min_ghz = 5;
  double max_ghz = 6;
}
 
message GPU {
  string brand = 1;
  string name = 2;
  double min_ghz = 3;
  double max_ghz = 4;
  Memory memory = 5;
}
```

A storage:

```go
import "memory_message.proto";
 
message Storage {
  enum Driver {
    UNKNOWN = 0;
    HDD = 1;
    SSD = 2;
  }
 
  Driver driver = 1;
  Memory memory = 2;
}
```

同样，我们将创建更多用于过滤和身份验证。你可以在这里找到所有这些：https://github.com/arkaprabha-majumdar/grpc-protoc/tree/main

那么现在我们看到了proto3的神奇之处。转到终端并创建一个单独的文件夹，其中包含相应的生成 Go 代码！这是因为我们添加了以下命令：

```shell
option go_package = "gengo";
```

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// protoc-gen-go v1.23.0
// protoc v3.10.0
// source: store_message.proto
```

接下来，我们为我们的笔记本电脑实现服务器所需的 create 函数：

```go
// unary RPC to create new laptop
func (server *myServer) CreateLaptop(
    ctx context.Context,
    req *pb.CreateLaptopRequest,
) (*pb.CreateLaptopResponse, error) {
    laptop := req.GetLaptop()
    log.Printf("receive a create-laptop request with id: %s", laptop.Id)
}
```

您会注意到我们使用的函数名称与 proto-gen-go 生成的函数名称相同。 接下来我们使用以下命令安装 Google UUID 包：

```go
go get github.com/google/uuid
```

所以现在我们可以解析笔记本电脑的 ID。如果没有，我们尝试生成一个新的笔记本电脑 ID。否则我们抛出一个错误。

```go
if len(laptop.Id) > 0 {
    // check if it's a valid UUID
    _, err := uuid.Parse(laptop.Id)
    if err != nil {
        return nil, status.Errorf(codes.InvalidArgument, "laptop ID invalid: %v", err)
    }
} else {
    id, err := uuid.NewRandom()
    if err != nil {
        return nil, status.Errorf(codes.Internal, "cannot generate new ID: %v", err)
    }
    laptop.Id = id.String()
}
```

接下来，我们检查请求是否超时或被客户端取消，以减少不必要的带宽损失。 

要检查这一点，我们只需使用 ctx.Err() 函数：

```go
f ctx.Err() == context.Canceled {
    log.Print("request is canceled")
    return nil, status.Error(codes.Canceled, "request already canceled")
}
 
if ctx.Err() == context.DeadlineExceeded {
    log.Print("deadline exceeded")
    return nil, status.Error(codes.DeadlineExceeded, "deadline exceeded")
}
```

然后为了存储我们收到的笔记本电脑，我们创建一个新文件 store.go ：

```go
// LaptopStore ...
type LaptopStore interface {
    // Save saves the laptop to the store
    Save(laptop *pb.Laptop) error
}
// InMemoryLaptopStore ...
type InMemoryLaptopStore struct {
    mutex sync.RWMutex
    data  map[string]*pb.Laptop
}
// NewInMemoryLaptopStore ...
func NewInMemoryLaptopStore() *InMemoryLaptopStore {
    return &InMemoryLaptopStore{
        data: make(map[string]*pb.Laptop),
    }
}
```

这会将笔记本电脑存储在内存中。我们也可以选择创建一个数据库。我们使用读写互斥体来处理并发请求。 我们已经使用了 Save 函数，但仍然没有定义它。所以我们现在就这样做：

```go
// Save ...
func (store *InMemoryLaptopStore) Save(laptop *pb.Laptop) error {
    store.mutex.Lock()
    defer store.mutex.Unlock()
 
    if store.data[laptop.Id] != nil {
        return ErrAlreadyExists
    }
 
    other, err := deepCopy(laptop)
    if err != nil {
        return err
    }
 
    store.data[other.Id] = other
    return nil
}
```

这将是关于它的服务器。我们将测试服务器。

### Test the handler

让我们创建一个 server_test.go 文件，并将测试用例添加到一个表中。查看 https://golangdocs.com/golang-unit-testing 了解更多详情。

```go
func TestServerCreateLaptop(t *testing.T) {
    t.Parallel()
 
    testCases := []struct {
        name   string
        laptop *pb.Laptop
        store  service.LaptopStore
        code   codes.Code
    }{
        {
            name:   "success_with_id",
            laptop: sample.NewLaptop(),
            store:  service.NewInMemoryLaptopStore(),
            code:   codes.OK,
        },
        {
            name:   "success_no_id",
            laptop: laptopNoID,
            store:  service.NewInMemoryLaptopStore(),
            code:   codes.OK,
        },
        {
            name:   "failure_invalid_id",
            laptop: laptopInvalidID,
            store:  service.NewInMemoryLaptopStore(),
            code:   codes.InvalidArgument,
        },
        {
            name:   "failure_duplicate_id",
            laptop: laptopDuplicateID,
            store:  storeDuplicateID,
            code:   codes.AlreadyExists,
        },
    }
}
```

您可以添加更多您喜欢的测试。 现在我们已经完成了，我们需要将 gRPC 连接到我们的真实服务器，然后实现实际的服务器和客户端。所以跳到最后一部分的下一部分：Unary gRPC with Golang – 2





## Reference
[Introduction to gRPC with Golang](https://golangdocs.com/grpc-golang)

[Unary gRPC with Golang](https://golangdocs.com/unary-grpc-golang)
